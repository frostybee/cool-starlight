---
// No React dependency needed
---

<div id="telescope-search" class="hidden">
  <div class="fixed inset-0 z-50 flex items-start justify-center pt-16 px-4 bg-black bg-opacity-50 backdrop-blur-sm">
    <div class="w-full max-w-2xl bg-gray-900 rounded-lg shadow-xl border border-gray-700 overflow-hidden">
      <!-- Search input -->
      <div class="p-4 border-b border-gray-700">
        <input
          id="search-input"
          type="text"
          placeholder="Search documentation..."
          class="w-full bg-gray-800 border-none rounded p-2 text-white placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:outline-none"
          autocomplete="off"
        />
      </div>

      <!-- Results panel -->
      <div id="search-results" class="max-h-96 overflow-y-auto">
        <!-- Results will be inserted here -->
      </div>

      <!-- Keyboard shortcuts help -->
      <div class="p-3 bg-gray-800 text-gray-400 text-xs flex justify-between border-t border-gray-700">
        <div>
          <span class="px-2 py-1 bg-gray-700 rounded mr-2">↑</span>
          <span class="px-2 py-1 bg-gray-700 rounded mr-2">↓</span>
          <span>to navigate</span>
        </div>
        <div>
          <span class="px-2 py-1 bg-gray-700 rounded mr-2">Enter</span>
          <span>to select</span>
        </div>
        <div>
          <span class="px-2 py-1 bg-gray-700 rounded mr-2">Esc</span>
          <span>to close</span>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Floating search button -->
<button
  id="search-button"
  aria-label="Search"
  class="fixed bottom-6 right-6 p-3 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 z-40"
>
  <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
  </svg>
</button>

<!-- full URL to a script on a remote server -->
<script is:inline src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js"></script>
<script>
//   import Fuse from '@fuse.js';

  // DOM elements
  const searchContainer = document.getElementById('telescope-search');
  const searchInput = document.getElementById('search-input');
  const resultsContainer = document.getElementById('search-results');
  const searchButton = document.getElementById('search-button');

  // Search state
  let searchIndex = null;
  let selectedIndex = -1;
  let searchResults = [];
  let searchTimeout = null;

  // Load search index
  async function loadSearchIndex() {
    if (searchIndex) return searchIndex;

    try {
      const response = await fetch('/pages.json');
      const pages = await response.json();

        console.log("loadSearchIndex", pages)
      searchIndex = new Fuse(pages, {
        keys: [
          { name: 'title', weight: 1.0 },
          { name: 'headings', weight: 0.75 },
          { name: 'description', weight: 0.5 },
          { name: 'content', weight: 0.3 },
        ],
        includeScore: true,
        includeMatches: true,
        threshold: 0.3,
        ignoreLocation: true,
        minMatchCharLength: 2,
      });

      return searchIndex;
    } catch (error) {
      console.error('Failed to load search index:', error);
      return null;
    }
  }

  // Open search modal
  function openSearch() {
    searchContainer.classList.remove('hidden');
    searchInput.focus();
    console.log("openSearch")

    // Load search index if not loaded
    loadSearchIndex();
  }

  // Close search modal
  function closeSearch() {
    searchContainer.classList.add('hidden');
    searchInput.value = '';
    clearResults();
  }

  // Clear search results
  function clearResults() {
    resultsContainer.innerHTML = '';
    searchResults = [];
    selectedIndex = -1;
  }

  // Perform search
  async function performSearch(query) {
    if (!query || query.length < 2) {
      clearResults();
      return;
    }

    const index = await loadSearchIndex();
    if (!index) return;

    searchResults = index.search(query).slice(0, 10);
    renderResults(searchResults, query);
  }

  // Render search results
  function renderResults(results, query) {
    if (results.length === 0) {
      resultsContainer.innerHTML = `
        <div class="p-4 text-gray-400 text-center">
          No results found for "${query}"
        </div>
      `;
      return;
    }

    resultsContainer.innerHTML = results.map((result, index) => {
      const highlightedTitle = getHighlightedText(result);
      const description = result.item.description.substring(0, 100) +
                          (result.item.description.length > 100 ? '...' : '');

      return `
        <a
          href="${result.item.url}"
          class="block p-3 border-b border-gray-700 hover:bg-gray-800 ${index === selectedIndex ? 'bg-gray-800' : ''}"
          data-index="${index}"
        >
          <div class="text-white font-medium">${highlightedTitle}</div>
          <div class="text-gray-400 text-sm truncate mt-1">${description}</div>
        </a>
      `;
    }).join('');

    // Add click listeners to results
    document.querySelectorAll('#search-results a').forEach(el => {
      el.addEventListener('click', closeSearch);
      el.addEventListener('mouseover', () => {
        selectedIndex = parseInt(el.dataset.index);
        updateSelectedResult();
      });
    });
  }

  // Get highlighted text for matched portions
  function getHighlightedText(result) {
    if (!result.matches || result.matches.length === 0) {
      return result.item.title;
    }

    // Find matches in the title
    const titleMatch = result.matches.find(match => match.key === 'title');
    if (!titleMatch || !titleMatch.indices.length) {
      return result.item.title;
    }

    // Create highlighted text with mark tags
    const text = titleMatch.value || result.item.title;
    let lastIndex = 0;
    let highlightedText = '';

    titleMatch.indices.forEach(([start, end]) => {
      highlightedText += text.substring(lastIndex, start);
      highlightedText += `<mark>${text.substring(start, end + 1)}</mark>`;
      lastIndex = end + 1;
    });

    highlightedText += text.substring(lastIndex);
    return highlightedText;
  }

  // Update the selected result
  function updateSelectedResult() {
    document.querySelectorAll('#search-results a').forEach((el, index) => {
      if (index === selectedIndex) {
        el.classList.add('bg-gray-800');
        el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
      } else {
        el.classList.remove('bg-gray-800');
      }
    });
  }

  // Navigate to the selected result
  function selectResult() {
    if (selectedIndex >= 0 && selectedIndex < searchResults.length) {
      window.location.href = searchResults[selectedIndex].item.url;
      closeSearch();
    }
  }

  // Handle keyboard navigation
  function handleKeyDown(event) {
    // If search is not open but Cmd+K or Ctrl+K is pressed, open it
    if ((event.metaKey || event.ctrlKey) && event.key === 'p') {
      event.preventDefault();

      if (searchContainer.classList.contains('hidden')) {
        openSearch();
      } else {
        closeSearch();
      }
      return;
    }

    // If search is not open, don't handle other keys
    if (searchContainer.classList.contains('hidden')) {
      return;
    }

    switch (event.key) {
      case 'ArrowDown':
        event.preventDefault();
        selectedIndex = Math.min(selectedIndex + 1, searchResults.length - 1);
        updateSelectedResult();
        break;

      case 'ArrowUp':
        event.preventDefault();
        selectedIndex = Math.max(selectedIndex - 1, 0);
        updateSelectedResult();
        break;

      case 'Enter':
        event.preventDefault();
        selectResult();
        break;

      case 'Escape':
        event.preventDefault();
        closeSearch();
        break;
    }
  }

  // Set up event listeners
  document.addEventListener('keydown', handleKeyDown);

  if (searchButton) {
    searchButton.addEventListener('click', openSearch);
  }

  if (searchInput) {
    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.trim();

      // Debounce search input
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        performSearch(query);
      }, 200);
    });
  }

  // Close when clicking outside search modal
  searchContainer.addEventListener('click', (e) => {
    if (e.target === searchContainer) {
      closeSearch();
    }
  });

  // Prefetch search index during idle time
  if ('requestIdleCallback' in window) {
    window.requestIdleCallback(() => {
      loadSearchIndex();
    });
  } else {
    setTimeout(() => {
      loadSearchIndex();
    }, 1000);
  }
</script>

<style>
  mark {
    background-color: rgba(59, 130, 246, 0.2);
    color: #60a5fa;
    font-weight: 600;
    border-radius: 2px;
    padding: 0 2px;
  }

  #search-button {
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    transition: transform 0.2s ease;
  }

  #search-button:hover {
    transform: translateY(-2px);
  }

  #search-button:active {
    transform: translateY(0);
  }
</style>
